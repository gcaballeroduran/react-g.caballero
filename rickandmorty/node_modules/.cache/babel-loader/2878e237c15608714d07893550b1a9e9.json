{"ast":null,"code":"/*jshint esversion:6*/\n'use strict';\n/**\n * This is the actual sort implementation.\n */\n\nfunction sort(beans) {\n  //TODO: we should actually sort first by priority if\n  //      it was previously declared\n  let graph = createGraph(beans);\n  let stack = weightPriorityByDependencies(beans, graph, true);\n  beans.map(plugin => plugin.priority = stack[plugin.id].priority);\n  /*\n   * Let's sort our modules based on their\n   * collected weight.\n   */\n\n  beans.sort((a, b) => {\n    if (a.priority < b.priority) return 1;\n  });\n  return beans;\n}\n/**\n * Provided a list of modules and their\n * dependencies, return an array containing\n * the modules ids ordered so that we can\n * load dependencies first.\n *\n * @argument {Object} graph Object containing modules\n *                          and their dependencies.\n *\n * @argument {Boolean} allowImplicit Should we create\n *                                    missing modules.\n *\n * @return {Array}  List of modules ordered by most\n *                  relied upon first.\n */\n\n\nfunction weightPriorityByDependencies(beans, graph, allowImplicit = true) {\n  /*\n   * store weight for each module\n   */\n  let stack = {};\n  /*\n   * Collect all available modules.\n   */\n\n  let modules = Object.keys(graph);\n  /*\n   * All modules start with an\n   * equal weight.\n   */\n\n  modules.forEach(id => stack[id] = {\n    priority: 0\n  });\n  /*\n   * Collect the weight for each module\n   */\n\n  modules.forEach(id => weight(stack, id, graph[id]));\n  /*\n   * Our system might try to recover from\n   * missing dependencies elsewhere, like\n   * if we support 'global' dependencies\n   * handled by require, etc.\n   */\n\n  function addMissingDependency(dependency) {\n    //TODO: review how this should work exactly :P\n    beans[dependency] = {\n      id: dependency,\n      priority: 1,\n      dependencies: [],\n      isLocal: false,\n      //TODO: This could potentially fail.\n      //How do we handle it?\n      plugin: require(dependency)\n    };\n    graph[dependency] = [];\n    stack[dependency] = 1;\n  }\n\n  function weight(stack, id, dependencies = [], i = 0) {\n    if (i > 10) throw Error('Cyclical dependency found: ' + findCyclicDependencies(graph, id));\n    if (!dependencies.length) return;\n    dependencies.map(dependency => {\n      if (!stack.hasOwnProperty(dependency)) {\n        if (!allowImplicit) throw new Error('Dependency \"' + dependency + '\" not a module.');\n        addMissingDependency(dependency);\n      }\n      /*\n       * increase the count of the module\n       * we are dependent on.\n       */\n\n\n      stack[dependency].priority++;\n      /*\n       * now, do the same for the dependency's\n       * dependencies...\n       */\n\n      weight(stack, dependency, graph[dependency], ++i);\n    });\n  }\n  /*\n   * If we allow implicit and we actually\n   * introduced an implicit dependency we\n   * might want to re-generate our module\n   * list.\n   */\n\n\n  if (allowImplicit) modules = Object.keys(graph);\n  return stack;\n}\n/**\n * Just go over our graph tree and\n * figure out where it went wrong.\n */\n\n\nfunction findCyclicDependencies(graph, identifier) {\n  let stack = {};\n\n  function find(id) {\n    if (stack.hasOwnProperty(id)) return id === identifier;\n    stack[id] = true;\n    let found = (graph[id] || []).some(find);\n    if (!found) delete stack[id];\n    return found;\n  }\n\n  return find(identifier) ? Object.keys(stack).concat(identifier) : undefined;\n}\n/**\n * Build a structure that is easier\n * to work with.\n */\n\n\nfunction createGraph(beans) {\n  let out = {};\n  beans.map(bean => {\n    out[bean.id] = bean.plugin.dependencies || [];\n  });\n  return out;\n}\n\nmodule.exports = sort;\nmodule.exports.createGraph = createGraph;\nmodule.exports.findCyclicDependencies = findCyclicDependencies;\nmodule.exports.weightPriorityByDependencies = weightPriorityByDependencies;","map":{"version":3,"sources":["/Users/gabycaballero/node_modules/in/lib/sortByDependencies.js"],"names":["sort","beans","graph","createGraph","stack","weightPriorityByDependencies","map","plugin","priority","id","a","b","allowImplicit","modules","Object","keys","forEach","weight","addMissingDependency","dependency","dependencies","isLocal","require","i","Error","findCyclicDependencies","length","hasOwnProperty","identifier","find","found","some","concat","undefined","out","bean","module","exports"],"mappings":"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","sourcesContent":["/*jshint esversion:6*/\n'use strict';\n\n/**\n * This is the actual sort implementation.\n */\nfunction sort(beans) {\n    //TODO: we should actually sort first by priority if\n    //      it was previously declared\n    let graph = createGraph(beans);\n    let stack = weightPriorityByDependencies(beans, graph, true);\n\n    beans.map(plugin => plugin.priority = stack[plugin.id].priority);\n\n    /*\n     * Let's sort our modules based on their\n     * collected weight.\n     */\n    beans.sort((a, b) => {\n        if (a.priority < b.priority) return 1;\n    });\n\n    return beans;\n}\n\n/**\n * Provided a list of modules and their\n * dependencies, return an array containing\n * the modules ids ordered so that we can\n * load dependencies first.\n *\n * @argument {Object} graph Object containing modules\n *                          and their dependencies.\n *\n * @argument {Boolean} allowImplicit Should we create\n *                                    missing modules.\n *\n * @return {Array}  List of modules ordered by most\n *                  relied upon first.\n */\nfunction weightPriorityByDependencies(beans, graph, allowImplicit = true) {\n    /*\n     * store weight for each module\n     */\n    let stack = {};\n\n    /*\n     * Collect all available modules.\n     */\n    let modules = Object.keys(graph);\n\n    /*\n     * All modules start with an\n     * equal weight.\n     */\n    modules.forEach(id => stack[id] = { priority: 0 });\n\n    /*\n     * Collect the weight for each module\n     */\n    modules.forEach(id => weight(stack, id, graph[id]));\n\n    /*\n     * Our system might try to recover from\n     * missing dependencies elsewhere, like\n     * if we support 'global' dependencies\n     * handled by require, etc.\n     */\n    function addMissingDependency(dependency) {\n        //TODO: review how this should work exactly :P\n        beans[dependency] = {\n            id: dependency,\n            priority: 1,\n            dependencies: [],\n            isLocal: false,\n            //TODO: This could potentially fail.\n            //How do we handle it?\n            plugin: require(dependency)\n        };\n\n        graph[dependency] = [];\n        stack[dependency] = 1;\n    }\n\n    function weight(stack, id, dependencies = [], i = 0) {\n        if (i > 10) throw Error('Cyclical dependency found: ' + findCyclicDependencies(graph, id));\n\n        if (!dependencies.length) return;\n\n        dependencies.map(dependency => {\n            if (!stack.hasOwnProperty(dependency)) {\n                if (!allowImplicit) throw new Error('Dependency \"' + dependency + '\" not a module.');\n                addMissingDependency(dependency);\n            }\n\n            /*\n             * increase the count of the module\n             * we are dependent on.\n             */\n            stack[dependency].priority++;\n\n            /*\n             * now, do the same for the dependency's\n             * dependencies...\n             */\n            weight(stack, dependency, graph[dependency], ++i);\n        });\n    }\n\n    /*\n     * If we allow implicit and we actually\n     * introduced an implicit dependency we\n     * might want to re-generate our module\n     * list.\n     */\n    if (allowImplicit) modules = Object.keys(graph);\n\n    return stack;\n}\n\n/**\n * Just go over our graph tree and\n * figure out where it went wrong.\n */\nfunction findCyclicDependencies(graph, identifier) {\n    let stack = {};\n\n    function find(id) {\n        if (stack.hasOwnProperty(id)) return id === identifier;\n\n        stack[id] = true;\n\n        let found = (graph[id] || []).some(find);\n\n        if (!found) delete stack[id];\n\n        return found;\n    }\n\n    return find(identifier) ? Object.keys(stack).concat(identifier) : undefined;\n}\n\n/**\n * Build a structure that is easier\n * to work with.\n */\nfunction createGraph(beans) {\n    let out = {};\n\n    beans.map(bean => {\n        out[bean.id] = bean.plugin.dependencies || [];\n    });\n\n    return out;\n}\n\nmodule.exports = sort;\nmodule.exports.createGraph = createGraph;\nmodule.exports.findCyclicDependencies = findCyclicDependencies;\nmodule.exports.weightPriorityByDependencies = weightPriorityByDependencies;"]},"metadata":{},"sourceType":"script"}